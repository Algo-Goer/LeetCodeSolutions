以下代码已全部AC。<br>

一共有三类方法，分别是：

- 根据测试案例写代码（人工解一遍，再让机器照做）
- 数学模型法（直接上公式，但边界条件需要分支考虑）
  - 写法一是if..return..if..return
  - 写法二是?:形式
- 数学模型法（直接上公式，把边界条件包含在一个公式里，无需分支）<br>（第三类方法代码行数最少，但用的脑子最多😂）

# 1518. 换酒问题<br>

小区便利店正在促销，用numExchange个空酒瓶可以兑换一瓶新酒。

你购入了numBottles瓶酒。
如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。

请你计算最多能喝到多少瓶酒。

<br>

**示例 1：**<br>
输入：<br>numBottles = 9,  numExchange = 3<br>
输出：13<br>
解释：<br>你可以用 3 个空酒瓶兑换 1 瓶酒。<br>
所以最多能喝到 9 + 3 + 1 = 13 瓶酒。

<br>

**示例 2：**<br>
输入：numBottles = 15, numExchange = 4<br>
输出：19<br>
解释：你可以用 4 个空酒瓶兑换 1 瓶酒。<br>
所以最多能喝到 15 + 3 + 1 = 19 瓶酒。

<br>

**示例 3：**<br>
输入：numBottles = 5, numExchange = 5<br>
输出：6

<br>


**示例 4：**<br>
输入：numBottles = 2, numExchange = 3
<br>
输出：2
 

<br>

提示：<br>
1 <= numBottles <= 100 
<br>
2 <= numExchange <= 100

<br>



![先用特殊性例子打个草稿热身一下<br>
荧光笔部分为关键](https://files.mdnice.com/user/19687/813667a2-6f47-4a4b-bc42-2cb4b143ad15.jpg)



<br>


```c
/*
 * @lc app=leetcode.cn id=1518 lang=c
 * 12.17 Fri.
 * [1518] 换酒问题
 */

// @lc code=start

int numWaterBottles(int numBottles, int numExchange)
{
    int ans = numBottles;
    while (numBottles >= numExchange) // 空瓶子大于等于兑换数时
    {
        int new = numBottles / numExchange; // 新兑换的数量
        ans += new;
        numBottles = numBottles % numExchange + new;  // 余数+新兑换的
    }
   
    return ans;
}
// @lc code=end
```

<br>


![扩展到普遍适用的数学模型](https://files.mdnice.com/user/19687/7b1da73e-6121-4822-8ce0-7fc180d494e4.jpg)

<br>

![模型思路](https://files.mdnice.com/user/19687/b67dbd73-a951-48da-82a3-3bdb45ae554f.jpg)

<br>


![注意最后一次的边界条件情况](https://files.mdnice.com/user/19687/b21a0bfa-9a7c-40d2-9311-c9749ce1379e.jpg)

<br>

由此，再写一个普适性数学模型的C代码(n=1):
```c
/*
 * @lc app=leetcode.cn id=1518 lang=c
 * 12.17 Fri.
 * [1518] 换酒问题边界条件分支考虑
 * 快解：
 * 每交换一次少(numExchange-1)个瓶子
 * 边界条件：
 * 如果numBottles/(numExchange-1)为0，那么最后一次要减去
 */

// @lc code=start

int numWaterBottles(int numBottles, int numExchange)
{
   int MaxExchange = numBottles / (numExchange - 1); // 最大可兑换次数
        if (numBottles % (numExchange - 1) == 0)
            return numBottles + numBottles / (numExchange - 1) - 1;
        else
            return numBottles + numBottles / (numExchange - 1);  
}
```
这里的if也可以写成“？：”形式:
```c
/*
 * @lc app=leetcode.cn id=1518 lang=c
 * 12.17 Fri.
 * [1518] 换酒问题边界条件分支考虑，分支的另一种写法
 * 快解：
 * 每交换一次少(numExchange-1)个瓶子
 * 边界条件：
 * 如果numBottles/(numExchange-1)为0，那么最后一次要减去
 */

// @lc code=start

int numWaterBottles(int numBottles, int numExchange)
{
    int MaxExchange = numBottles / (numExchange - 1); // 最大可兑换次数
    return (numBottles % (numExchange - 1) == 0) ? numBottles + numBottles / (numExchange - 1) - 1 : numBottles + numBottles / (numExchange - 1);
}
```

<br>


![第三类方法代码行数最少，<br>但需要数学思想用的最多](https://files.mdnice.com/user/19687/10ff337e-8ee4-47df-bcd9-5ab0eb4a0917.jpg)

<br>


```c
/*
 * @lc app=leetcode.cn id=1518 lang=c
 * 12.17 Fri.
 * [1518] 换酒问题
 * 最快解：
 * 每交换一次少(numExchange-1)个瓶子
 * 不需要考虑边界条件：
 * (numBottles-1)/(numExchange-1)+numBottles
 */

// @lc code=start

int numWaterBottles(int numBottles, int numExchange)
{
    return (numBottles-1)/(numExchange-1) + numBottles;
}
```

